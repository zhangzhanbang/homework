---
  title : Problem Solving and Algorithm Design
---

## 索引 ##
* [1、阅读 Pseudocode Standard](#1)
	* [1）用伪代码描述将十进制转换成16进制的方法](#2)
	* [2）C语言实现（先用注释写好算法，然后翻译）](#3)
	* [3）使用 -1, 0, 1, 15, 26，3265 最为输入测试你的程序](#4)
* [2、名词解释与对比](#5)
	* [1）Top-down design](#6)
	* [2）Work breakdown structure (WBS)](#7)
	* [3）简述管理学 WBS 与 信息学Top-down设计 的异同](#8)
* [3、观察您洗衣机的运作过程](#9)
	* [1）请使用伪代码分解“正常洗衣”程序的大步骤](#10) 
	* [2）写出每个步骤的伪代码](#11)
	* [3）分析“正常洗衣”与“快速洗衣”在用户目标和程序上的异同](#12)
	* [4）提取一些共性功能模块，简化“正常洗衣”程序](#13)

<h2 id="1"> 1、阅读 Pseudocode Standard </h2>

<h3 id="2"> 1）用伪代码描述将十进制转换成16进制的方法 </h3>

```c 
//a 是输入的10进制数, b 是中间变量
//b 是转化后的16进制数
READ a
b <- 1
c <- 0

WHILE a > 0 //将10进制的a转化为16进制的c
DO
	c <- c + a % 16 * b
	b <- b * 16
	a <- a / 16
END WHILE

WHILE c > 0 //将16进制的c输出
DO
	b <- c % 16
	IF b < 10 Print b
	ELSE
		CASE b OF
			10 : Print 'A'
			11 : Print 'B'
			12 : Print 'C'
			13 : Print 'D'
			14 : Print 'E'
			15 : Print 'F'
		END CASE	
END WHILE
```

<h3 id="3"> 2）C语言实现（先用注释写好算法，然后翻译）</h3>

```c
int a, b = 1, c = 0;
scanf("%d", &a);
while (a > 0) //将10进制的a转化为16进制的c
{
	c += (a % 16 * b), b *= 16;
	a /= 16;
}
while (c > 0) //将16进制的c输出
{
	int dig = c % 16;
	if (dig < 10) printf("%d", dig);
	else printf("%c", 'A' + dig - 10);
}
```

<h3 id="4"> 3）使用 -1, 0, 1, 15, 26，3265 最为输入测试你的程序 </h3>

- $ (-1)_ {10} = (‭FFFFFFFFFFFFFFFF‬)_ {16} $ 
- $ (0)_ {10} = (0)_ {16} $
- $ (1)_ {10} = (1)_ {16} $
- $ (15)_ {10} = (F)_ {16} $
- $ (26)_ {10} =  (1A)_ {16} $
- $ (3265)_ {10} =  (CC1)_ {16} $


<h2 id="5"> 2、名词解释与对比 </h2>

<h3 id="6"> 1）Top-down design </h3>

- Top-down approaches emphasize planning and a complete understanding of the system. It is inherent that no coding can begin until a sufficient level of detail has been reached in the design of at least some part of the system. 
- Top-down（由上而下）是一种设计与解决问题的技巧，对问题先有一个整体的概念，然后再逐步加上设计细节，最后让整体得轮廓越来越清楚

<h3 id="7"> 2） Work breakdown structure (WBS) </h3>

- A work-breakdown structure (WBS) in project management and systems engineering, is a deliverable-oriented breakdown of a project into smaller components. A work breakdown structure is a key project deliverable that organizes the team's work into manageable sections. 
- 工作分解结构即把一个项目，按一定的原则分解，项目分解成任务，任务再分解成一项项工作，再把一项项工作分配到每个人的日常活动中，直到分解不下去为止。工作分解结构，以可交付成果为导向对项目要素进行的分组，它归纳和定义了项目的整个工作范围，每下降一层代表对项目工作的更详细定义。
- [详细解释](https://wiki.mbalib.com/wiki/%E5%B7%A5%E4%BD%9C%E5%88%86%E8%A7%A3%E7%BB%93%E6%9E%84)

<h3 id="8"> 3）简述管理学 WBS 与 信息学Top-down设计 的异同 </h3>

-  异：两个方法是分属于管理学领域与信息学领域
-  同：都是以整体到局部解决问题

<h2 id="9"> 3、仔细观察您洗衣机的运作过程，运用Top-down设计方法和Pseudocode 描述洗衣机控制程序。</h2>

> 假设洗衣机可执行的基本操作如下：<br/>
> water_in_switch(open_close) // open 打开上水开关，close关闭  <br/>
> water_out_switch(open_close) // open 打开排水开关，close关闭  <br/>
> get_water_volume() //返回洗衣机内部水的高度  <br/>
> motor_run(direction) // 电机转动。left左转，right右转，stop停 <br/>
> time_counter() // 返回当前时间计数，以秒为单位 <br/>
> halt(returncode) //停机，success 成功 failure 失败 <br/>

<h3 id="10"> 1）请使用伪代码分解“正常洗衣”程序的大步骤。包括注水、浸泡等 </h3>

```python
1.漂洗(含注水)
2.脱水
3.停机
```

<h3 id="11"> 2）进一步用基本操作、控制语句（IF、FOR、WHILE等）、变量与表达式，写出每个步骤的伪代码 </h3>

#### *0-1 注水

```c
water_in_switch(open)
water_out_switch(close)
WHILE get_water_volume() < need_volume
DO
	DO NOTHING
END WHILE
water_in_switch(close)
```

#### *0-2 排水

```c
water_out_switch(open)
WHILE get_water_volume() > 0
DO
	DO NOTHING
END WHILE
water_out_switch(close)
```

#### *0-3 滚筒转动(time)
```c
begin_time <- time_counter()
WHILE time_counter() < begin_time + time
DO
	motor_run(left)
	motor_run(right)
	motor_run(stop)
END
```

#### 1）漂洗
```c
注水()
滚筒转动(time)
排水()
```

#### 2）脱水
```c
滚筒转动(time)
```

#### 3）停机
```c
halt(success)
```

<h3 id="12"> 3）根据你的实践，请分析“正常洗衣”与“快速洗衣”在用户目标和程序上的异同。你认为是否存在改进（创新）空间，简单说明你的改进意见？  </h3>

| 模式 | 用户目标 | 程序差异 |
|:-:|:-:|:-:|
| 正常洗衣 | 洗干净 | 洗衣时间长，漂洗次数多 |
| 快速洗衣 | 洗得快 | 洗衣时间短，漂洗次数少 |

#### 改进意见
- 两个功能大部分操作相同，只是执行时间不同，程序可采用模块化编程，代码简洁化

<h3 id="13"> 4）通过步骤3），提取一些共性功能模块（函数），简化“正常洗衣”程序，使程序变得更利于人类理解和修改维护。 </h3>
> 例如： <br/>
> wait(time) //等待指定的时间；<br/>
> 注水(volume,timeout) //在指定时间内完成注水，否则停机；<br/>
> 排水(timeout)。 等子程序

#### wait(time)
```c
begin_time <- time_counter()
WHILE time_counter() < begin_time + time
DO
	DO NOTHING
END WHILE
```

#### 注水(volume, timeout)
```c
water_in_switch(open)
water_out_switch(close)
begin_time <- time_counter()
WHILE get_water_volume() < volume
DO
	IF time_counter() > begin_time + timeout
		halt(failure)
END WHILE
water_in_switch(close)
```

#### 排水(timeout)

```c
water_out_switch(open)
begin_time <- time_counter()
WHILE get_water_volume() > 0
DO
	IF time_counter > begin_time + timeout
		halt(failure)
	END IF
END WHILE
water_in_switch(open)
```
